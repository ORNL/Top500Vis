<!DOCTYPE html>
<meta charset="utf-8" />
<html>
  <head>
    <!-- <script src="https://d3js.org/d3.v5.min.js"></script> -->
    <script src="js/d3.min.js"></script>
    <script src="js/d3-array.min.js"></script>
    <script src="js/heatmapChart.js"></script>

    <style>
      body {
        font: 12px sans-serif;
        /* margin: 4px 20px 0px 20px; */
        /* background: gray; */
        background-color: whitesmoke;
      }

      .top {
        background-color: whitesmoke;
        overflow: hidden;
        position: fixed;
        top: 0;
        width: 100%;
      }

      .main {
        margin-top: 400px;
      }

      table {
        width: 100%;
      }

      #logo {
        text-align: right;
      }
    </style>
  </head>
  <body>
    <table>
      <tr>
        <td>
          <h2>Supercomputing <a href="http://top500.org" target="_blank">Top500</a> List Heatmap Visualization</h2>
          <strong>Data Source:</strong> <a href="http://top500.org" target="_blank">Top500 List</a> from the <a href="https://www.icl.utk.edu/" target="_blank">Univ. of Tennessee Innovative Computing Laboratory</a> <br/>
          <strong>Author:</strong> <a href="https://csteed.com" target="_blank">Chad A. Steed</a>, <a href="https://vis.ornl.gov" target="_blank">VISTA Lab</a>, <a href="https://www.ornl.gov/division/csmd" target="_blank">Computer Science and Mathematics Division</a>, <a href="https://ornl.gov" target="_blank">Oak Ridge National Laboratory</a>
          <br/><br/>
        </td>

        <td id="logo"><a href="https://vis.ornl.gov/" target="_blank"><img src="img/vista-logo.png" height=70 alt="ORNL VISTA Vis Lab"></img></a></td>
      </tr>
    </table>

    <h3>Description:</h3>
    <p>
    </p>

    <h3>Controls:</h3>
    <p>
      <label for="groupFieldSelect">Group Field: </label>
      <select id="groupFieldSelect" onChange="groupFieldSelectChanged()">
        <option selected>Country</option>
        <option>Continent</option>
        <option>Computer</option>
        <option>Manufacturer</option>
        <option>Region</option>
        <option>Segment</option>
        <option>Site</option>
      </select><br/><br/>
    </p>

    <div id="chart"></div>
  </body>

  <script>
    let parseTime = d3.timeParse("%Y-%m");
    let fileData;
    let chartData;
    let chart;
    const margin = {top: 60, right: 20, bottom: 30, left: 300};
    const rowHeight = 12;

    const removeSpaces = (str) => {
      return str.replace(/\s+/g, '');
    };

    const getSelectedGroupField = () => {
      const select = document.getElementById('groupFieldSelect');
      return select.options[select.selectedIndex].text;
    };

    const groupFieldSelectChanged = () => {
      loadData();
      createChart();
    };

    const loadData = () => {
      // console.log(fileData);

      const selectedGroupField = getSelectedGroupField().toLowerCase();
      // console.log(`Selected Group Field: ${selectedGroupField}`);

      let groupValue;
      if (selectedGroupField === 'computer') {
        groupValue = d => {return `${d.computer}:${d.site}`};
      } else {
        groupValue = d => d[selectedGroupField];
      }

      const nestedGroups = d3.nest()
        .key(groupValue).sortKeys(d3.ascending)
        .sortValues((a,b) => d3.ascending(a.date, b.date))
        .entries(fileData);

      // console.log(nestedGroups);

      const dates = [...new Set(fileData.map(d => d.date))].sort(d3.ascending);
      console.log(dates);

      const names = [];
      const values = [];
      nestedGroups.forEach(groupNode => {
        names.push(groupNode.key);
        let groupValues = new Array(dates.length);

        groupNode.values.forEach(d => {
          const dateIndex = dates.indexOf(d.date);
          if (isNaN(groupValues[dateIndex])) {
            groupValues[dateIndex] = d.rank;
          } else {
            if (d.rank < groupValues[dateIndex]) {
              groupValues[dateIndex] = d.rank;
            }
          }
        });
        values.push(groupValues);
      });

      chartData = {
        dates: dates.map(d => parseTime(d)),
        rows: names.map((d,i) => {
          return {
            name: d,
            start: values[i].findIndex(d => !isNaN(d)),
            end: findEndIndex(values[i]),
            values: values[i]
          }
        })
      }

      chartData.rows.sort(orders.Duration);
      console.log(chartData);
    };

    const findEndIndex = (d) => {
      for (let i = d.length; i >= 0; i--) {
        if (d[i]) {
          return i;
        }
      }
      return -1;
    }
    const orders = ({
      Start: (a, b) => d3.ascending(a.start, b.start),
      End: (a, b) => d3.descending(a.end, b.end),
      Duration: (a, b) => {
        if (a.end - a.start === b.end - b.start) {
          return orders.Start(a,b);
        } else {
          return d3.descending(a.end - a.start, b.end - b.start)
        }
      }
    });

    const createChart = () => {
      d3.select('#chart').selectAll('*').remove();
      if (chartData) {
        const divWidth = document.getElementById('chart').clientWidth;
        const height = chartData.rows.length * rowHeight + margin.top + margin.bottom;
        console.log(height);

        chart = heatmapChart()
          .margin(margin)
          .width(divWidth)
          .height(height);
        d3.select('#chart').call(chart, chartData);
      }
    };

    const createChartOld = () => {
      if (names && values && dates) {
        d3.select('#chart').selectAll('*').remove();

        const divWidth = document.getElementById('chart').clientWidth;
        const width = divWidth - margin.left - margin.right;
        const height = names.length * rowHeight;

        const svg = d3.select('#chart').append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);

        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const x = d3.scaleBand()
          // .domain([d3.min(dates),d3.max(dates)])
          .domain(dates)
          .rangeRound([0, width]);

        const y = d3.scaleBand()
          .domain(names)
          .rangeRound([0, height]);
        
        const color = d3.scaleSequential([d3.max(values, d => d3.max(d)), 1], d3.interpolateGreens);

        g.append("g")
          .call(d3.axisTop(x))
          .call(g => g.select(".domain").remove());

        g.append("g")
          .call(d3.axisLeft(y).tickSize(0))
          .call(g => g.select(".domain").remove());

        const row = g.append("g")
          .selectAll("g")
          .data(values)
          .join("g")
            .attr("transform", (d, i) => `translate(0,${y(names[i])})`);
          
        row.selectAll("rect")
          .data(d => d)
          .join("rect")
            // .attr("x", (d, i) => x(dates[i]) + 1)
            .attr("x", (d, i) => x(dates[i]))
            // .attr("width", (d, i) => x(dates[i+1]) - x(dates[i]) - 1)
            .attr("width", x.bandwidth())
            .attr("height", y.bandwidth() - 1)
            .attr("fill", d => isNaN(d) ? "whitesmoke" : d === 1 ? "black" : color(d))
          .append("title")
            .text((d, i) => `Rank ${d} in ${dates[i]}`);
      }
    };

        
    d3.csv(
      "output.csv",
      ({
        date, rank, computer, site, rmax, rpeak, manufacturer, name, segment, country, continent, power, region
      }) => ({
        // date: parseTime(date),
        date,
        rank: +rank,
        computer: computer,
        site: site.trim(),
        rmax: +rmax,
        rpeak: +rpeak,
        manufacturer: manufacturer,
        name: name,
        segment: segment,
        country: country,
        continent: continent,
        region: region,
        power: +power
      })
    )
      .then(function(data) {
        fileData = data;
        loadData();
        createChart();
      })
      .catch(function(error) {
        console.log(error);
      });
  </script>
</html>
