<!DOCTYPE html>
<meta charset="utf-8" />
<html>
  <head>
    <!-- <script src="https://d3js.org/d3.v5.min.js"></script> -->
    <script src="js/d3.min.js"></script>
    <script src="js/d3-array.min.js"></script>
    <script src="js/d3-delaunay.min.js"></script>

    <style>
      body {
        font: 12px sans-serif;
        /* margin: 4px 20px 0px 20px; */
        /* background: gray; */
        background-color: whitesmoke;
      }

      .top {
        background-color: whitesmoke;
        overflow: hidden;
        position: fixed;
        top: 0;
        width: 100%;
      }

      .main {
        margin-top: 400px;
      }
    </style>
  </head>
  <body>
    <h2>Supercomputing Top500 Heatmap Visualization</h2>
    <h3>Description:</h3>
    <p>
    </p>

    <h3>Controls:</h3>
    <p>
      <label for="groupFieldSelect">Group Field: </label>
      <select id="groupFieldSelect" onChange="groupFieldSelectChanged()">
        <option selected>Country</option>
        <option>Continent</option>
        <option>Computer</option>
        <option>Manufacturer</option>
        <option>Region</option>
        <option>Segment</option>
        <option>Site</option>
      </select><br/><br/>
    </p>

    <div id="chart" style="position: relative;"></div>
  </body>

  <script>
    let parseTime = d3.timeParse("%Y-%m");
    let fileData;
    let chartData;
    let svg;
    const margin = {top: 20, right: 20, bottom: 30, left: 40};
    const rowHeight = 12;

    var dates;
    var ranks;
    // var voronoi;
    var foregroundData;
    var backgroundData;
    
    const removeSpaces = (str) => {
      return str.replace(/\s+/g, '');
    };

    const getSelectedGroupField = () => {
      const select = document.getElementById('groupFieldSelect');
      return select.options[select.selectedIndex].text;
    };

    const groupFieldSelectChanged = () => {
      loadData();
      createChart();
    };

    const loadData = () => {
      // console.log(fileData);

      const selectedGroupField = getSelectedGroupField().toLowerCase();
      // console.log(`Selected Group Field: ${selectedGroupField}`);

      let groupValue;
      if (selectedGroupField === 'computer') {
        groupValue = d => {return `${d.computer}:${d.site}`};
      } else {
        groupValue = d => d[selectedGroupField];
      }

      const nestedGroups = d3.nest()
        .key(groupValue).sortKeys(d3.ascending)
        .sortValues((a,b) => d3.ascending(a.date, b.date))
        .entries(fileData);

      // console.log(nestedGroups);

      dates = [...new Set(fileData.map(d => d.date))].sort(d3.ascending);
      // console.log(dates);

      chartData = [];
      nestedGroups.forEach(groupNode => {
        var groupObject = {
          name: groupNode.key,
          values: new Array(dates.length)
        };
        groupNode.values.forEach(d => {
          const dateIndex = dates.indexOf(d.date);
          if (isNaN(groupObject.values[dateIndex])) {
            groupObject.values[dateIndex] = d.rank;
          } else {
            if (d.rank < groupObject.values[dateIndex]) {
              groupObject.values[dateIndex] = d.rank;
            }
          }
        });
        chartData.push(groupObject);
      });

      chartData.map(d => {
        var newValues = [];
        d.values.map((v,i) => {
          if (!isNaN(v)) {
            newValues.push({
              name: d.name,
              date: dates[i],
              value: v
            });
          }
        });
        d.values = newValues;
      })
      console.log(chartData);

      ranks = d3.merge(chartData.map(d => d.values.map(s => ({name: d, rank: s}))));
      console.log(ranks);
      // nestedGroups.forEach(groupNode => {
      //   names.push(groupNode.key);
      //   let groupValues = new Array(dates.length);
      //   groupNode.values.forEach(d => {
      //     const dateIndex = dates.indexOf(d.date);
      //     if (isNaN(groupValues[dateIndex])) {
      //       groupValues[dateIndex] = d.rank;
      //     } else {
      //       if (d.rank < groupValues[dateIndex]) {
      //         groupValues[dateIndex] = d.rank;
      //       }
      //     }
      //   });
      //   values.push(groupValues);
      // });
    };

    const createChart = () => {
      if (chartData) {
        d3.select('#chart').selectAll('*').remove();

        const divWidth = document.getElementById('chart').clientWidth;
        const width = divWidth - margin.left - margin.right;
        const height = 800;

        const backgroundCanvas = d3.select('#chart').append('canvas')
          .attr('id', 'background')
          .attr('width', width + 1)
          .attr('height', height + 1)
          .style('position', 'absolute')
          .style('top', `${margin.top}px`)
          .style('left', `${margin.left}px`);
        const background = backgroundCanvas.node().getContext('2d');
        background.strokeStyle = "rgba(0,0,0)";
        background.globalAlpha = 0.1;
        background.antialias = true;
        background.lineWidth = 1;

        const foregroundCanvas = d3.select('#chart').append('canvas')
          .attr('id', 'foreground')
          .attr('width', width + 1)
          .attr('height', height + 1)
          .style('position', 'absolute')
          .style('top', `${margin.top}px`)
          .style('left', `${margin.left}px`);
        const foreground = foregroundCanvas.node().getContext('2d');
        foreground.strokeStyle = "rgba(0,100,160)";
        foreground.globalAlpha = 0.8;
        foreground.antialias = true;
        foreground.lineWidth = 1;
        foreground.translate(0.5, 0.5);

        const svg = d3.select('#chart').append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .style('position', 'absolute')
          .append('svg:g')
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const x = d3.scalePoint()
          .domain(dates)
          .padding(0.5)
          .rangeRound([0, width]);

        const y = d3.scaleLinear()
          .domain([1,500]).nice()
          .range([0, height]);
        
        svg.append("g")
          .call(d3.axisTop(x))
          .call(g => g.select(".domain").remove());

        svg.append("g")
          // .call(d3.axisLeft(y).tickSize(0))
          .call(d3.axisLeft(y))
          .call(g => g.select(".domain").remove());

        foregroundData = chartData;
        backgroundData = [];
        drawLines();

        function path(data, ctx) {
          // draw line
          // console.log(data);
          ctx.beginPath();
          data.values.map((d,i) => {
            if (i === 0) {
              // ctx.moveTo(x(d.date), y(d.value));
              ctx.moveTo(x(d.date)-2, y(d.value));
              ctx.lineTo(x(d.date)+2, y(d.value));
            } else {
              // ctx.lineTo(x(d.date), y(d.value));
              ctx.lineTo(x(d.date)-2, y(d.value));
              ctx.lineTo(x(d.date)+2, y(d.value));
            }
          });
          ctx.stroke();
        }

        function drawLines() {
          drawBackground();
          drawForeground();
        }

        function drawForeground() {
          foreground.clearRect(0, 0, width + 1, height + 1);
          foregroundData.map(d => path(d, foreground));
        }

        function drawBackground() {
          background.clearRect(0, 0, width + 1, height + 1);
          backgroundData.map(d => path(d, background));
        }

        const voronoi = d3.Delaunay
          .from(ranks, d => x(d.rank.date), d => y(d.rank.value))
          .voronoi([0, 0, width, height]);
        
        const tooltip = g => {
          const tooltip = g.append("g")
            .style("font", "10px sans-serif");

          const path = tooltip.append("path")
            .attr("fill", "white")
            .attr("fill-opacity", 0.5);

          const text = tooltip.append("text");

          const line1 = text.append("tspan")
            .attr("x", 0)
            .attr("y", 0)
            .style("font-weight", "bold");
          
          const line2 = text.append("tspan")
            .attr("x", 0)
            .attr("y", "1.1em");

          const line3 = text.append("tspan")
            .attr("x", 0)
            .attr("y", "2.2em");

          g.append("g")
              .attr("fill", "none")
              .attr("pointer-events", "all")
            .selectAll("path")
            .data(ranks)
            .join("path")
              .attr("d", (d, i) => voronoi.renderCell(i))
              .on("mouseout", () => {
                tooltip.style("display", "none")
                foreground.globalAlpha = 0.4;
                foreground.lineWidth = 1;
                foregroundData = chartData;
                backgroundData = [];
                drawLines();
              })
              .on("mouseover", d => {
                // console.log(d);
                tooltip.style("display", null);
                line1.text(`${d.name.name}`);
                line2.text(`${'#'}${d.rank.value}`);
                line3.text(`${d.rank.date}`);
                path.attr("stroke", "black");
                const box = text.node().getBBox();

                /* Works for left side
                path.attr("d", `
                  M${box.x - 10},${box.y - 10}
                  h${box.width + 20}
                  V${box.y + (box.height / 2 - 5)}l5,5l-5,5
                  V${box.y + (box.height + 10)}
                  h-${box.width + 20}
                  z
                `);
                tooltip.attr("transform", `translate(${
                  x(d.rank.date) - box.width - 24 },${
                  y(d.rank.value) - box.height / 2 - box.y
                })`);  
                */
                
                if (x(d.rank.date) + box.width + 20 > width) {
                  console.log('tooltip clipped on right side');
                    path.attr("d", `
                    M${box.x - 10},${box.y - 10}
                    h${box.width + 20}
                    V${box.y + (box.height / 2 - 5)}l5,5l-5,5
                    V${box.y + (box.height + 10)}
                    h-${box.width + 20}
                    z
                  `);
                  tooltip.attr("transform", `translate(${
                    x(d.rank.date) - box.width - 24 },${
                    y(d.rank.value) - box.height / 2 - box.y
                  })`); 
                } else {
                  path.attr("d", `
                    M${box.x - 10},${box.y - 10}
                    V${box.y + (box.height / 2 - 5)}l-5,5l5,5
                    V${box.y + (box.height + 10)}
                    h${box.width + 20}
                    V${box.y - 10}
                    z
                  `);
                  tooltip.attr("transform", `translate(${
                    x(d.rank.date) + 24 },${
                    y(d.rank.value) - box.height / 2 - box.y
                  })`);  
                }
                
                // if (x(d.rank.date) - box.width / 2 < 0) {
                //   console.log('tooltip clipped on left side');
                // } else if (x(d.rank.date) + box.width / 2 > width) {
                //   console.log('tooltip clipped on right side');
                // }
                // pointing left
                // path.attr("d", `
                //   M${box.x - 10},${box.y - 10}
                //   V${box.height / 2 - 5}l-5,5l5,5
                //   V${box.height + 10}
                //   h${box.width + 20}
                //   v-${box.height + 20}
                //   z
                // `);
                // path.attr("d", `
                //   M${box.x - 10},${box.y - 10}
                //   H${box.width + 10}
                //   v${box.height + 20}
                //   h-${box.width + 20}
                //   z
                // `);
                // console.log(box);
                // path.attr("d", `
                //   M${box.x - 10},${box.y - 10}
                //   V${box.height}
                //   h${box.width + 20}
                //   V${box.y - 10}
                //   z
                // `);
                /* Works on right side
                path.attr("d", `
                  M${box.x - 10},${box.y - 10}
                  V${box.y + (box.height / 2 - 5)}l-5,5l5,5
                  V${box.y + (box.height + 10)}
                  h${box.width + 20}
                  V${box.y - 10}
                  z
                `);
                tooltip.attr("transform", `translate(${
                  x(d.rank.date) + 24 },${
                  y(d.rank.value) - box.height / 2 - box.y
                })`);
                */
                // path.attr("d", `
                //   M${box.x - 10},${box.y - 10}
                //   H${box.width / 2 - 5}l5,-5l5,5
                //   H${box.width + 10}
                //   v${box.height + 20}
                //   h-${box.width + 20}
                //   z
                // `);
                // tooltip.attr("transform", `translate(${
                //   x(d.rank.date) - box.width / 2},${
                //   y(d.rank.value) + 28
                // })`);

                foregroundData = [];
                backgroundData = [];
                foreground.globalAlpha = 1.;
                foreground.lineWidth = 2;
                chartData.map(s => {
                  if (s.name === d.name.name) {
                    foregroundData.push(s);
                  } else {
                    backgroundData.push(s);
                  }
                });
                drawLines();
                // string.attr("stroke", "#ddd");
                // string.selectAll("path")
                //   // .attr("stroke", s => s.name === d.name.name ? "black" : "#ddd")
                //   .attr("stroke-opacity", s => s.name === d.name.name ? null : 0.2)
                //   .attr("stroke-width", s => s.name === d.name.name ? 2 : null);
                // string.selectAll("path")
                //   .filter(s => s.name === d.name.name).raise();
                // string.selectAll("circle")
                //   .attr("fill-opacity", s => s.name === d.name.name ? 'none' : 0.2)
                //   .filter(s => s.name === d.name.name).raise();
              });
        };
          
        svg.append("g")
          .call(tooltip);
        
      }
    };

    const createChartOld = () => {
      if (chartData) {
        d3.select('#chart').selectAll('*').remove();

        const divWidth = document.getElementById('chart').clientWidth;
        const width = divWidth - margin.left - margin.right;
        const height = 800;
        // const height = 500 * rowHeight;

        const svg = d3.select('#chart').append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);

        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        const rankExtents = [
          d3.min(chartData, d => d3.min(d.values, v => v.value)),
          d3.max(chartData, d => d3.max(d.values, v => v.value))
        ];
        console.log(rankExtents);

        const line = d3.line()
          .curve(d3.curveLinear)
          .x(d => x(d.date))
          .y(d => y(d.value));
          // .defined(d => !isNaN(d))
          // .x((d,i) => x(dates[i]))
          // .y(d => y(d));

        const x = d3.scalePoint()
          .domain(dates)
          .rangeRound([0, width]);

        const y = d3.scaleLinear()
          .domain([1,500]).nice()
          .range([0, height]);
        
        g.append("g")
          .call(d3.axisTop(x))
          .call(g => g.select(".domain").remove());

        g.append("g")
          .call(d3.axisLeft(y).tickSize(0))
          .call(g => g.select(".domain").remove());

        const string = g.append("g")
            .attr("stroke-width", 1.)
          .selectAll("g")
          .data(chartData)
          .join("g");

        string.append("path")
          .attr("fill", "none")
          .attr("stroke", "black")
          .attr("stroke-linejoin", "round")
          .attr("stroke-linecap", "round")
          // .style("mix-blend-mode", "multiply")
          .attr("stroke-opacity", 0.3)
          .attr("d", d => line(d.values));

        // const dot = string.append("g")
        //     .attr("stroke", "white")
        //     .attr("fill", "black")
        //     .attr("fill-opacity", 0.3)
        //   .selectAll("circle")
        //   .data(d => d.values)
        //   .join("circle")
        //     .attr("transform", d => `translate(${x(d.date)},${y(d.value)})`)
        //     .attr("r", 2.5);
        // console.log(dot);
        
        const voronoi = d3.Delaunay
          .from(ranks, d => x(d.rank.date), d => y(d.rank.value))
          .voronoi([0, 0, width, height]);
        
        const tooltip = g => {
          const tooltip = g.append("g")
            .style("font", "10px sans-serif");

          const path = tooltip.append("path")
            .attr("fill", "white");

          const text = tooltip.append("text");

          const line1 = text.append("tspan")
            .attr("x", 0)
            .attr("y", 0)
            .style("font-weight", "bold");
          
          const line2 = text.append("tspan")
            .attr("x", 0)
            .attr("y", "1.1em");

          const line3 = text.append("tspan")
            .attr("x", 0)
            .attr("y", "2.2em");

          g.append("g")
              .attr("fill", "none")
              .attr("pointer-events", "all")
            .selectAll("path")
            .data(ranks)
            .join("path")
              .attr("d", (d, i) => voronoi.renderCell(i))
              .on("mouseout", () => tooltip.style("display", "none"))
              .on("mouseover", d => {
                // console.log(d);
                tooltip.style("display", null);
                line1.text(`${d.name.name}`);
                line2.text(`${'#'}${d.rank.value}`);
                line3.text(`${d.rank.date}`);
                path.attr("stroke", "black");
                const box = text.node().getBBox();
                path.attr("d", `
                  M${box.x - 10},${box.y - 10}
                  H${box.width / 2 - 5}l5,-5l5,5
                  H${box.width + 10}
                  v${box.height + 20}
                  h-${box.width + 20}
                  z
                `);
                tooltip.attr("transform", `translate(${
                  x(d.rank.date) - box.width / 2},${
                  y(d.rank.value) + 28
                })`);
                // string.attr("stroke", "#ddd");
                string.selectAll("path")
                  // .attr("stroke", s => s.name === d.name.name ? "black" : "#ddd")
                  .attr("stroke-opacity", s => s.name === d.name.name ? null : 0.2)
                  .attr("stroke-width", s => s.name === d.name.name ? 2 : null);
                string.selectAll("path")
                  .filter(s => s.name === d.name.name).raise();
                // string.selectAll("circle")
                //   .attr("fill-opacity", s => s.name === d.name.name ? 'none' : 0.2)
                //   .filter(s => s.name === d.name.name).raise();
              });
        };
          
        g.append("g")
          .call(tooltip);
        
      }
    };
        
    d3.csv(
      "output.csv",
      ({
        date, rank, computer, site, rmax, rpeak, manufacturer, name, segment, country, continent, power, region
      }) => ({
        // date: parseTime(date),
        date,
        rank: +rank,
        computer: computer,
        site: site.trim(),
        rmax: +rmax,
        rpeak: +rpeak,
        manufacturer: manufacturer,
        name: name,
        segment: segment,
        country: country,
        continent: continent,
        region: region,
        power: +power
      })
    )
      .then(function(data) {
        fileData = data;
        loadData();
        createChart();
      })
      .catch(function(error) {
        console.log(error);
      });
  </script>
</html>
