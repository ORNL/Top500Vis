<!DOCTYPE html>
<meta charset="utf-8" />
<html>
  <head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
      body {
        font: 12px sans-serif;
        /* margin: 4px 20px 0px 20px; */
        /* background: gray; */
        background-color: whitesmoke;
      }

      .top {
        background-color: whitesmoke;
        overflow: hidden;
        position: fixed;
        top: 0;
        width: 100%;
      }

      .main {
        margin-top: 400px;
      }
    </style>
  </head>
  <body>
    <div class="top">
      <h2>Supercomputing Top500 Streamgraph Visualization</h2>
      <h3>Description:</h3>
      <p>
        This webpage presents selected statistics from the <a href="http://top500.org" target="_blank">Top500</a> rankings of supercomputers as a streamgraph chart based on the style of <a href="http://leebyron.com/streamgraph/" target="_blank">Lee Byron <i>et al</i></a>.
      </p>
      <ul>
        <li><b>Area Field:</b> Select the field to assign to stream areas</li>
        <li><b>Value Field:</b> Select the value for sizing areas</li>
        <li><b>Highlight Area:</b> Select specific area to highlight</li>
        <li><b>White Horizontal Lines:</b> Show the dates of Top500 rankings</li>
        <li><b>Area Colors:</b> Encode the value sum for each ranking of the area</li>
      </ul>
      <h3>Controls:</h3>
      <p>
        <label for="areaFieldSelect">Area Field: </label>
        <select id="areaFieldSelect" onChange="areaFieldSelectChanged()">
          <option selected>Country</option>
          <option>Continent</option>
          <option>Computer</option>
          <option>Manufacturer</option>
          <option>Region</option>
          <option>Segment</option>
          <option>Site</option>
        </select><br/><br/>
        <label for="valueFieldSelect">Value Field: </label>
        <select id="valueFieldSelect" onChange="valueFieldSelectChanged()">
          <option selected>% of RMax for each Ranking</option>
          <option>RMax</option>
          <option>% of RPeak for each Ranking</option>
          <option>RPeak</option>
          <!-- <!-- <option>Rank</option> --> -->
          <!-- <option>Processors</option> -->
          <option>Power</option>
        </select><br/><br/>
        <label for="highlightAreaSelect">Highlight Area: </label>
        <select id="highlightAreaSelect" onChange="highlightAreaSelectChanged()"></select><br/><br/>
        <label for="countryFilterSelect">Country Filter: </label>
        <select id="countryFilterSelect" onChange="countryFilterSelectChanged()"></select>
      </p>
      <hr/>
    </div>
    <div class="main">
      <div id="chart"></div>
    </div>
    <center>
      <h4>&copy; <a href="https://www.ornl.gov">Oak Ridge National Laboratory</a>
          <script type="text/javascript">
              document.write(new Date().getFullYear());
          </script>
      </h4>
    </center>
  </body>

  <script>
    let parseTime = d3.timeParse("%Y-%m");
    let fileData;
    let dates;
    let chartData;
    let titleIDMap;
    let svg;
    let zNormal;
    let zHover;
    let currentHighlightArea;
    // const highlightColor = "#1E8449";
    const highlightColor = "dodgerblue"
    // const highlightColor = d3.rgb(128, 120, 183);

    const removeSpaces = (str) => {
      return str.replace(/\s+/g, '');
    };

    const getSelectedAreaField = () => {
      const select = document.getElementById('areaFieldSelect');
      return select.options[select.selectedIndex].text;
    };

    const getSelectedValueField = () => {
      const select = document.getElementById('valueFieldSelect');
      return select.options[select.selectedIndex].text;
    };

    const getSelectedHighlightArea = () => {
      const select = document.getElementById('highlightAreaSelect');
      return select.options[select.selectedIndex].text;
    }

    const getSelectedCountryFilter = () => {
      const select = document.getElementById('countryFilterSelect');
      return select.options[select.selectedIndex].text;
    }

    const areaFieldSelectChanged = () => {
      loadData();
      createChart();
      populateHighlightAreaSelect();
    };

    const valueFieldSelectChanged = () => {
      loadData();
      createChart();
    };

    const highlightAreaSelectChanged = () => {
      const selectedHighlightArea = getSelectedHighlightArea();

      if (currentHighlightArea) {
        const areaID = titleIDMap.get(currentHighlightArea);
        svg.select(`.areaPath#${areaID}`)
          .transition().duration(500)
          .attr("fill", d => zNormal(d.sum));
      }

      if (selectedHighlightArea != 'Choose Highlight Area') {
        const areaID = titleIDMap.get(selectedHighlightArea);
        svg.select(`.areaPath#${areaID}`)
          .transition().duration(500)
          .attr("fill", d => zHover(d.sum));
          // .attr("fill", "#1E8449");
        currentHighlightArea = selectedHighlightArea;
      } else {
        currentHighlightArea = null;
      }

      // if (selectedHighlightArea === 'Choose Highlight Area') {
      //   svg.selectAll('.areaPath')
      //     .attr("fill", d => z(d.sum));
      // } else {
      //   svg.selectAll('.areaPath')
      //     .transition().duration(500)
      //     .attr("fill", d => d.key === selectedHighlightArea ? "#1E8449" : z(d.sum));
          
      // }
      // const areaID = titleIDMap.get(selectedHighlightArea);
      // console.log(`highlighing ${selectedHighlightArea} with ID ${areaID}`);
      // svg.select(`.areaPath#${areaID}`).attr("fill", "green");
      // svg.select(`.areaPath#${titleIDMap.get("China")}`)
        // .attr("fill", "green");
    };

    const populateHighlightAreaSelect = () => {
      const select = document.getElementById('highlightAreaSelect');
      for (let i = select.options.length - 1; i >= 0; i--) {
        select.remove(i);
      }

      const highlightOptions = [...titleIDMap.keys()];
      // console.log(highlightOptions);

      highlightOptions.sort(d3.ascending);
      highlightOptions.unshift('Choose Highlight Area');
      highlightOptions.forEach(option => {
        select.options[select.options.length] = new Option(option);
      });
    };

    const populateCountryFilterSelect = () => {
      const select = document.getElementById('countryFilterSelect');
      for (let i = select.options.length - 1; i >= 0; i--) {
        select.remove(i);
      }

      const countries = [...new Set(fileData.map(d => d.country))];
      console.log(countries);
      countries.sort(d3.ascending);
      countries.unshift('All');
      countries.forEach(country => {
        select.options[select.options.length] = new Option(country);
      });
    };

    const countryFilterSelectChanged = () => {
      // const select = document.getElementById('countryFilterSelect');
      // const selectedCountry = select.options[select.selectedIndex].text;
      // console.log(`selectedCountry: ${selectedCountry}`);
      loadData();
      createChart();
    };

    const loadData = () => {
      const selectedAreaField = getSelectedAreaField().toLowerCase();
      const getTitle = d => d[selectedAreaField];
      let selectedValueField = getSelectedValueField().toLowerCase();
      if (selectedValueField === '% of rmax for each ranking') {
        selectedValueField = 'percentRmax';
      }
      if (selectedValueField === '% of rpeak for each ranking') {
        selectedValueField = 'percentRpeak';
      }
      const getMetric = d => d[selectedValueField];
      // const getMetric = d => d.awesomeness;
      // const getTitle = d => d.country;

      let dateGroups;
      const selectedCountryFilter = getSelectedCountryFilter();
      if (selectedCountryFilter != 'All') {
        dateGroups = d3.nest().key(d => d.date).entries(fileData.filter(d => d.country === selectedCountryFilter));
      } else {
        dateGroups = d3.nest().key(d => d.date).entries(fileData);
      }

      // const dateGroups = d3.nest().key(d => d.date).entries(fileData);
      console.log(dateGroups);

      // make a new metric that is percent of highest rmax for ranking
      dateGroups.forEach(dateGroup => {
        const sumRmax = d3.sum(dateGroup.values, d => d.rmax);
        const sumRpeak = d3.sum(dateGroup.values, d => d.rpeak);
        // const maxRmax = d3.max(dateGroup.values, d => d.rmax);
        dateGroup.values.forEach(v => {
          const percentRmax = (v.rmax / sumRmax) * 100.;
          v['percentRmax'] = percentRmax;
          const percentRpeak = (v.rpeak / sumRpeak) * 100.;
          v['percentRpeak'] = percentRpeak;
        });
      });

      // console.log(dateGroups);

      chartData = [];
      let titles = new Set;
      dateGroups.forEach(dateGroup => {
        let sites = Object.create(null);
        dateGroup.values.forEach(value => {
          titles.add(getTitle(value))
          if (!sites[getTitle(value)]) {
            sites[getTitle(value)] = getMetric(value);
          } else {
            if (getMetric(value) > sites[getTitle(value)]) {
              sites[getTitle(value)] = getMetric(value);
            }
          }
        });
        chartData.push({
          date: new Date(dateGroup.key),
          sites
        });
        Object.assign(chartData, {titles: Array.from(titles)});
      });
      // console.log(chartData);

      const getRandomInt = (min, max) => {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1) + min);
      }

      titleIDMap = new Map();
      chartData.titles.forEach(title => {
        const titleID = `${removeSpaces(title).substring(0,2).toLowerCase()}${getRandomInt(1000,9999)}`;
        while (titleIDMap.has(titleID)) {
          titleID = `${removeSpaces(title).substring(0,3).toLowerCase()}${getRandomInt(1000,9999)}`;
        }
        titleIDMap.set(title, titleID);
      });

      console.log(titleIDMap);
    };


    const createChart = () => {
      d3.select('#chart').selectAll('*').remove();

      const stack = d3.stack()
        .keys(chartData.titles)
        .offset(d3.stackOffsetWiggle)
        .order(d3.stackOrderInsideOut)
        .value((d, key) => d.sites[key] || 0);
        // .value((d, key) => {console.log(d); return d.sites[key] || 0;});

      // console.log(stack);

      const series = stack(chartData);
      for (const s of series) {
        s.sum = d3.sum(s, d => d[1] - d[0]);
      }
      // console.log(series);

      const margin = ({top: 20, right: 40, bottom: 60, left: 20});
      const width = document.getElementById('chart').clientWidth;
      const height = width / 3.8;
      // const height = 560;
      // const width = height * 3.8;
      // const width = 700;
      // const height = width * 4.5;

      const area = d3.area()
        .curve(d3.curveBasis)
        .x((d, i) => x(chartData[i].date))
        .y0(d => y(d[0]))
        .y1(d => y(d[1]));
        // .y((d, i) => y(chartData[i].date))
        // .x0(d => x(d[0]))
        // .x1(d => x(d[1]));

      zNormal = d3.scaleSequentialSqrt(t => d3.interpolateBlues((t + 0.5) / 2))
        .domain(d3.extent(series, d => d.sum));

      zHover = d3.scaleSequentialSqrt(t => d3.interpolateOranges((t + 0.5) / 2))
        .domain(d3.extent(series, d => d.sum));
      
      const x = d3.scaleTime()
        .domain(d3.extent(chartData, d => d.date))
        .rangeRound([margin.left, width - margin.right]);

      const y = d3.scaleLinear()
        .domain([
          d3.min(series, d => d3.min(d, d => d[0])),
          d3.max(series, d => d3.max(d, d => d[1]))
        ])
        .range([height - margin.bottom, margin.top]);

      svg = d3.select('#chart').append("svg")
        .attr("width", width)
        .attr("height", height);

      svg.append("g")
        .attr("transform", `translate(0, ${height - margin.bottom})`)
        .call(d3.axisBottom(x)
          .tickValues(dates)
          .tickSize(-(height - margin.bottom - margin.top))
          .tickFormat(d => d.toLocaleString(undefined, {month: "short", year: "numeric"})))
        .call(g => g.select(".domain").remove())
        .call(g => g.selectAll(".tick line").attr("stroke", "#ccc"))
        .call(g => g.selectAll(".tick text").attr("fill", "gray"))
        .call(g => g.selectAll("text").attr("y", 0).attr("x", 9).attr("dy", ".35em").attr("transform", "rotate(90)").style("text-anchor", "start"));

      // svg.append("g")
      //   // .attr("transform", `translate(${width - margin.right}, 0)`)
      //   // .call(d3.axisRight(y)
      //   .attr("transform", `translate(0, ${height - margin.bottom})`)
      //   .call(d3.axisBottom(x)
      //     .ticks(d3.timeMonth.every(3))
      //     .tickFormat(d => d.toLocaleString(undefined, {month: "short"})))
      //   .call(g => g.selectAll(".tick text").attr("fill", "gray"))
      //   .call(g => g.selectAll(".tick line").attr("stroke", "#ccc"))
      //   .call(g => g.select(".domain").remove());
      
      // svg.append("g")
      //   .attr("transform", `translate(0, ${margin.top})`)
      //   // .attr("transform", `translate(${margin.left},0)`)
      //   // .call(d3.axisRight(y)
      //   .call(d3.axisTop(x)
      //     .ticks(d3.timeYear)
      //     // .tickSize(width - margin.right)
      //     .tickSize(-(height - margin.bottom - margin.top))
      //     .tickFormat(d => d.toLocaleString(undefined, {year: "numeric"})))
      //   .call(g => g.select(".domain").remove())
      //   .call(g => g.selectAll(".tick line").attr("stroke", "#ccc"))
      //   .call(g => g.selectAll(".tick text").attr("fill", "gray"));
      //   // .call(g => g.selectAll(".tick text").attr("fill", "gray").attr("x", null).attr("dy", "-0.6em"));

      svg.append("g")
        .selectAll("path")
        .data(series)
        .join("path")
          .attr("fill", d => zNormal(d.sum))
          .attr("d", area)
          .attr("class", "areaPath")
          .attr("id", d => `${titleIDMap.get(d.key)}`)
          .on("mouseover", d => {
            // console.log(d3.select(`#${titleIDMap.get(d.key)}`));
            d3.select(`#${titleIDMap.get(d.key)}`).attr("fill", d => zHover(d.sum));
            // d3.select(this).attr("fill", "orange");
            // d3.select(this).select(`#${titleIDMap.get(d.key)}`).attr("fill", d => zHover(d.sum));
          })
          .on("mouseout", d => {
            d3.select(`#${titleIDMap.get(d.key)}`).attr("fill", d => zNormal(d.sum));
            // d3.select(this).attr("fill", zNormal(d.sum));
          })
        .append("title")
          .text(d => d.key);  
              
      // svg.append("g")
      //   .selectAll("rankingLine")
      //     .data(chartData)
      //   .enter().append("line")
      //     .attr("stroke", "ghostwhite")
      //     .attr("stroke-width", 1.5)
      //     .attr("opacity", 0.25)
      //     .attr("y1", margin.top)
      //     .attr("x1", d => x(d.date))
      //     .attr("y2", height-margin.bottom)
      //     .attr("x2", d => x(d.date));
    };
        
    d3.csv(
      "output.csv",
      ({
        date, rank, computer, site, rmax, rpeak, manufacturer, name, segment, country, continent, power, region,
      }) => ({
        date: parseTime(date),
        rank: 501 - (+rank) ,
        computer: computer,
        site: site,
        rmax: +rmax,
        rpeak: +rpeak,
        manufacturer: manufacturer,
        name: name,
        segment: segment,
        country: country,
        continent: continent,
        region: region,
        power: +power
      })
    )
      .then(function(data) {
        fileData = data;
        dates = [...new Set(fileData.map(d => d.date))];
        populateCountryFilterSelect();
        loadData();
        createChart();
        populateHighlightAreaSelect();
      })
      .catch(function(error) {
        console.log(error);
      });
  </script>
</html>
